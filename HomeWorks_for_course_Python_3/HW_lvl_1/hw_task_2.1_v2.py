# Домашняя работа по задаче 2.1 курса Python 3: Версия 2.

# Задача 2.1. (Условие)

# Создайте две функции maximum и minimum,
# которые получают список целых чисел в качестве входных данных 
# и возвращают наибольшее и наименьшее число в этом списке соответственно.
# Например,
# * [4,6,2,1,9,63,-134,566]         -> max = 566, min = -134
# * [-52, 56, 30, 29, -54, 0, -110] -> min = -110, max = 56
# * [42, 54, 65, 87, 0]             -> min = 0, max = 87
# * [5]                             -> min = 5, max = 5
# функции sorted, max и min использовать нельзя!



# Решение 3
print('\n') # Пустая строка для разделения вывода в консоли

# Попробуем написать функцию, которая будет принимать вообще любые цифровые
# и/или списочные (в любых количествах и в любом порядке, - вперемежку) значения.
# Главное, что бы внутри всего этого были только числа!
#  Соответственно надо через (*arg) и распаковывать внутри. 
# Вопрос - количества вложенностей... 
# Т.к. с рекурсивными ф-ми я пока недоразобрался, - будет пока только 1 уровень распаковки, наверное


def unpack(*arg, Only_num=True): # Напишем отдельную ф-ю для распаковки
    '''
    Распаковывает 1 уровневую упаковку в список.

    Принимает любые списки или штучные переменные в любом порядке.

    Only_num=True - удаляет не цифры из полученного списка.
    '''
    
    sequence = [] # Создаем общий список
    
    for element in arg: 
        if type(element) == list or type(element) == tuple: # Проверяем на вложенность
                element = list(element)
                for num_ in element: # Распаковываем в новый список
                    sequence.append(num_)   
        else:
            sequence.append(element) # Добавляем в список штучные элементы

    if Only_num != True: # Проверяем обязательное условие (на числа) 
        return sequence # Если не нужны только числа, выводим всё
    else: # Если нужны только числа (удаляем все прочее), (м.б. это в отдельную ф-ю надо?)
        j = 0
        while j <= len(sequence)-1:
            if type(sequence[j]) != int and type(sequence[j]) != float:
                del sequence[j] # Удаляем элемент из списка если не число
                j -= 1 # Откатываем индекс при удалении элемента
            j += 1

        return sequence


# Далее вложим ф-ю для распаоквки в любую ф-ю для сравнения или операциями с числами в списке.
# Согласно поставленной задаче: для определения Мин. и Макс. из чисел.  

def get_minimum(*arg: int|float|list|tuple):
    '''
    Определяет минимальное значение в списке чисел.

    В качестве аргументов принимает в любом порядке ссылки на списки или кортежи чисел, 
    и/или любые числа.
    '''
    sequence = unpack(*arg, Only_num=True) # "распакуем" заданный список аргументов и удалим не числа.
    # Далее все как в ф-ях из задачи 2.1 
    min_value = sequence[0] # Начальное значение для сравнения
    for i in range(len(sequence)): # Проходим по списку (длине)
        if min_value >= sequence[i]: # Сравниваем текущий мин. с каждым значением
            min_value = sequence[i] # Присваиваем наименьшее из двух
    return min_value # Возвращаем результат

# Для Максимума (или другой операции с числами) тот же принцип [Приводить пример незачем вроде]
# Можно, наверное, описать ф-ю распаковки внутри конкретной ф-ю сравнения, но это - много и не логично
# И, если я правильно понимаю, подобный подход и есть - создание модуля?
# где можно описать разные операции и вызывать (импортировать) нужные ф-и в код (из модуля)   



# Проверка работы функциий (ниже)
# Для примера возьмем списки из условия задачи и пару "своих" 

L1 = (4,6,2,1,9,63,-134,566)         #-> min = -134, max = 566
L2 = [-52, 56, 30, 29, -54, 0, -110] #-> min = -110, max = 56
L3 = [42, 54, 65, 87, 0]             #-> min = 0,    max = 87
L4 = [5]                             #-> min = 5,    max = 5      

L5 = (44, 86, -15, 1, 9.2, -63.5, -134, 566, -200.2) #-> min = -200.2, max = 566
L6 = [-58, 63, -30.2, 115.02, 29, -54, 0, -110]      #-> min = -110,   max = 115.02

# Проверка работы функции для Решения 3 (минимальное значение)

fun_1 = get_minimum(L6) # Списки для проверок определены выше. Можно поменять номер у 'L' [1-6].
fun_2 = get_minimum(5, 25 , -120 , 2.25 , 50.3 , -18.2 , 48) # Только числа
fun_3 = get_minimum(L6, 5, 25 , -120 , 2.25 , 50.3 , -18.2 , 48) # внешний список и + числа
fun_4 = get_minimum(6) # Одно число
fun_5 = get_minimum(1, 'dlfk', 'dfdf', L1, L2, 'dfdf', 'dlfk', 5, 3.2, L4, 'dfdf', 0, -112.5, L6, L5) # Все в кучу
# fun_5 = get_minimum(1, 'dlfk', 'dfdf')

fun = fun_5 # Укажем Номер одной из 'fun' выше для вывода в консоль.

print(fun) # Выведем в консоль результат работы функции (минимум из списка)

# Конец проверки. Конец Решения 3.



print('\n') # Пустая строка для разделения вывода в консоли
