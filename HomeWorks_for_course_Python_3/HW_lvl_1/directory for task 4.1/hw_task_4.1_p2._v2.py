# Домашняя работа по задаче 4.1 курса Python 3 (Продолжение)

# Задача 4.1. (Условие)
# ...........
# Напишите программу, с помощью которой по ID студента можно получать информацию о школе и студенте.

# Формат вывода:

# ID Студента:
# Имя студента:
# ID школы:
# Название школы:

# Students: Student_Id, Student_Name, School_Id
# School:   School_Id,  School_Name,  Place_Count


# Решение 2. (п.2)
# Т.к. БД может быть гораздо ошбирнее, чем в уроке, 
# Имеет смысл немного универсализировать решение 


import sqlite3


# Напишем ф-ю для получения выборки из БД в виде Таблицы, согласно запросу.
def request_table_from_db(request: str, path_to_db: str) -> list:
    '''Получает и Выводит из БД сводную таблицу согласно запросу.'''
    try:
        con = sqlite3.connect(path_to_db) # Подключаемся к БД
        cur = con.cursor() # Создаем "указатель"
        cur.execute(request) # Выполняем запрос к БД
        table = cur.fetchall() # Присваиваем как таблицу
        con.close() # Отключаемся от БД.
        return table # Возвращаем таблицу (список кортежей) (в т.ч. пустой)
    
    except: print('Неверный запрос для БД') # 

# Можно добавить доп.необязательный аргумент для выбора кол-ва строк


# Напишем ф-ю для получения запроса к БД из двух таблиц
def create_query_join(table_1: str, columns_1: list|tuple,\
                      table_2: str, columns_2: list|tuple,\
                      join_name_column: str, join_type: int|str = 0) -> str:
    '''Возвращает строку для запроса к SQL.

    "join_name_column" - имя Столбца для объединения таблиц. 
    "join_type" - тип объединения (0 - по умолчанию = JOIN)
    (-1 or LEFT, 1 or RIGHT, 10 or FULL, -10 or CROSS)
    ''' # Можно, м.б., как-то более наглядно (цифрами) определить...
    try:
        # Переопределим 'join_type' для проверки (т.к. ввод числа или строки)
        # if type(join_type) == int: join_type = str(join_type)
        # elif type(join_type) == str: join_type = join_type.lower()
        # else: print('!Проверьте правильность значения для join_type!') # join_type будет по умолчанию
        join_type = str(join_type).lower() # Оказалось - этого достаточно (иначе: по умолчанию)

        # Проверим введеное значение и определим тип JOIN
        if join_type == '-1' or join_type == 'left': join_ = 'LEFT JOIN'
        elif join_type == '1' or join_type == 'right': join_ = 'RIGHT JOIN'
        elif join_type == '-10' or join_type == 'cross': join_ = 'CROSS JOIN'
        elif join_type == '10' or join_type == 'full': join_ = 'FULL JOIN'
        else: join_ = 'JOIN' # По умолчанию.

        # Составим список для SELECT (объединив таблицы со своими столбцами)
        column_names = []
        for column_1 in columns_1:
            column_names.append(table_1 + '.' + column_1)
        for column_2 in columns_2:
            column_names.append(table_2 + '.' + column_2)

        # Вернем строку с готовым запросом (кол-во пробелов - не играет роли)
        return f'''
        SELECT {", ".join(column_names)} 
        FROM {table_1} 
        {join_} {table_2} 
        ON {table_1}.{join_name_column} = {table_2}.{join_name_column};'''
    
    except AttributeError: print('AttributeError: Не верный тип для join_type')
    except TypeError: print('TypeError: Проверьте тип входящих переменных')

# Т.к. можно объединить сколько угодно таблиц, то нужна будет ф-я с др. подходом к аргументам.


# Чисто для примера оставим прошлую ф-ю из Решения 1, (для проверки).
# Добавим к ней второй аргумент в виде таблицы. 
def get_student_(student_Id: int, table: list) -> str:
    '''Получаем данные по ученику и его школе по ID ученика'''
    try:
        id = None
        for row in table: # Используем внешнюю переменную (при ее наличии)
            if row[0] == student_Id:
                id = student_Id
                print('ID ученика:', row[0])
                print('Имя ученика:', row[1])
                print('ID школы:', row[2])
                print('Название школы:', row[3], '\n')
        if id == None: print('Такого ID не существует')
    except: print('Ошибка идентификации Таблицы')

# Основной минус подобного решения в том, что каждый раз необходимо перечислять, 
# называть и выводить вручную все нужные столбцы, а их м.б. много.


# Поэтому, напишем ф-ю, которая будет выводить все элементы строки, по заданному значению (id),
# подписывая их названиями соответствующих столбцов. (они имеются для др. запросов)
def get_details(element_id, table: list, columns_name: list|tuple) -> str:
    '''Получаем подписанные данные из Таблицы по ID'''
    try:
        _id_ = False # Создадим флаг, для проверки искомого ID
        for names in table: # Проходим по элементам таблицы (строкам)
            if names[0] == element_id: # при наличии совпадения
                _id_ = True # активируем флаг
                for i, name in enumerate(columns_name): # выбираем имена столбцов             
                    print(f"{name}: {names[i]}") # Выводим результат (можно в словарь, и в return)
                break # Прерываем поиск, если нашли нужное (т.к. у нас только 1 элемент м.б.)
        if _id_ == False: print('Такого значения не существует')
    except: print('Ошибка идентификации Таблицы')



# Модифицируем предыдущю ф-ю (чисто для интереса), что бы она могла выводить подписанные данные
# по любому указанному (по имени или №) столбцу и соответствующему значению для него.
def get_detail_by(element_name, by_column: str|int, columns_name: list|tuple, table: list) -> str:
    '''Получаем подписанные данные из Таблицы по заданному элементу указанного столбца.
    
    by_column можно указать как по имени, так и по его номеру в columns_name'''
    try:
        _id_ = False # Создадим флаг, для проверки искомого элемента
        if type(by_column) == int: _ind_ = by_column # Проверим на тип и зададим Индекс
        elif type(by_column) == str: _ind_ = columns_name.index(by_column) # Нумерация от 0 (всегда)
        else: print('Неверный тип для столбца, по которому идет поиск.') # Если не в пределах
        
        for row in table: # Проходим по Таблице
            if row[_ind_] == element_name: # Сравниваем Элемент с заданным в нужном Столбце
                _id_ = True
                for i, name in enumerate(columns_name):                
                    print(f"{name}: {row[i]}") # Так же - можно в словарь для вывода
                print('\n') # Разделитель для нескольких выводов 
                # (тут без break, т.к. м.б. несколько результатов)
        if _id_ == False: print('Такого значения не существует')
    except IndexError: print('Неправильное значение столбца для поиска.')
    except: print('Ошибка идентификации Таблицы')



# Проверка Решения 2 (п.2)
print('\n') # Пустая строка для разделения вывода в консоли
# На основе уже обновленной БД (из п.1) (или собственных значений - ниже)

# request = '''
# SELECT Students.Student_Id, Students.Student_Name, School.School_Id, School.School_Name
# FROM Students
# JOIN School
# ON Students.School_Id = School.School_Id;
# ''' # Проверочный запрос, созданный вручную (можно и так делать, для вставки в ф-ю)

# table = [(201, 'Иван', 1, 'Протон'), # Проверочная Таблица (с доп. значениями)
#          (202, 'Иван', 2, 'Преспектива '), 
#          (203, 'Мария', 1, 'Протон'), 
#          (204, 'Екатерина', 2, 'Преспектива '),
#          (205, 'Анастасия', 3, 'Спектр'), 
#          (206, 'Игорь', 4, 'Содружество')]


path = 'teachers_.db' # т.к. БД в основной директории (без явного пути)

tab1 = "Students" # Имя Таблицы 1
tab2 = "School"   # Имя Таблицы 2
col1 = ['Student_Id', 'Student_Name'] # Список Столбцов из Таблицы 1
col2 = 'School_Id', 'School_Name'     # Список Столбцов из Таблицы 2
join = 'School_Id' # Имя Столбца, общего для двух Таблиц (для объединения)

columns_name = list(col1) + list(col2) # Названия Столбцов для подписей результатов


request = create_query_join(tab1, col1, tab2, col2, join, 'LefT') # Получаем "запрос" к БД для двух Таблиц
table = request_table_from_db(request, path) # Получаем "рабочую" Таблицу из БД (согласно запросу)


student_Id = 204 # Укажем проверочный номер, для основной задачи (№ id ученика)

print('Результат работы Старой ф-и:', '\n')
get_student_(student_Id, table) # Выводим результаты сразу из ф-и (изнутри), для сравнения с др.


print() # Пустая строка

print('Результат работы Основной ф-и:', '\n') # для любого количества столбцов
get_details(student_Id, table, columns_name) # Проверка работы ф-и. (Вывод изнутри)


print('\n') # Пустая строка с доп.разделителем

# Для проверки последней (модифицированной) ф-и.
element_name = 'Иван' # Значение для Столбца 2: (он же -3 или 'Student_Name')
by_column = -3 #'Student_Name' # Имя (или №) Столбца для поиска Значений (element_name)

print('Результат работы Модифицированной ф-и:', '\n') # При наличии выдаст все совпадения с запросом
print(f'Выбор значений осуществляется по Имени студента: {element_name} \n\
соответствующего столбца: {by_column}.', '\n') # Добавочный текст к последнему выводу (ниже)

get_detail_by(element_name, by_column, columns_name, table) # Проверка работы ф-и. (Вывод изнутри)


# # #(ниже) Для проверки полученных промежуточных значений
# print('\n') # Пустая 
# print(columns_name) # Напечатать список Столбцов для названий
# print('\n') # Пустая 
# print(table) # Вывести все элементы полученной Таблицы (из запроса)
# print('\n') # Пустая 
# print(request) # Проверка составления Запроса (вывод результата)


# Конец Решения 2 (п.2) для Задачи 4.1 (по sql)
print('\n') # Пустая строка для разделения вывода в консоли

# !!! Для решения, как было на уроке, надо всего лишь составить правильно 
# внутренний запрос к SQL ч-з JOIN внутри ф-и,
# и там же обработать полученный результат. (принципы - ровно те же) 
# Я решил не повторять решение подобным образом (тем более - уже было на уроке схоже).