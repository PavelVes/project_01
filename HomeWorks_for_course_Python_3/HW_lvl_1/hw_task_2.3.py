# Домашняя работа по задаче 2.2 курса Python 3

# Задача 2.3. (Условие)

# Напишите функцию, которая принимает цифры от 0 до 9 и возвращает значение прописью.
# Например,
# switch_it_up(1) -> 'One'
# switch_it_up(3) -> 'Three'
# switch_it_up(10000) -> None
# Использовать условный оператор if-elif-else нельзя!

# def switch_it_up(number):
#     pass


# Решение 0.
print('\n') # Пустая строка для разделения вывода в консоли

# Раз "слова" откуда-то брать надо, самое очевидное - составить список и брать оттуда.
# А сам список (или словарь - лучше) сделать внутренней переменной для функции
# И просто выбирать по номеру.  (но это - не интересно.) 



# Решение 1. (название функции как бы намекает :)...)

def switch_it_up(digit: int) -> str:
    '''Возвращает название цифры [0-9]'''
    
    match str(digit):
        case '1':
            return 'Один'
        case '2':
            return 'Два'
        case '3':
            return 'Три'
        case '4':
            return 'Четыре'
        case '5':
            return 'Пять'
        case '6':
            return 'Шесть'
        case '7':
            return 'Семь'
        case '8':
            return 'Восемь'
        case '9':
            return 'Девять'
        case '0':
            return 'Ноль'
        case _:
            return '!Нет такой цифры!'


# Проверка работы функции (Решения 1.)

digit = 2 # Зададим значение (цифру или не...)

print('Цифра', digit, 'пишется пропиьсю как:', switch_it_up(digit)) # Выведем в консоль результат.

# Но это сработает только с одноразрядной цифрой, но не числом большей разрядности
# Или просто замучаешься называть все числа :).  [Довольно громоздкий, на вид, способ] 

# Конец Решения 1.



# Решение 2.
print('\n') # Пустая строка для разделения вывода в консоли

# Напишем ф-ю, которая будет писать прописью любое произносимое целое число (до N разрядов)
# Например, для документов, где надо обязательно указать значение (суммы) прописью
# И... - нам все равно понадобятся названия для цифр (сделаем это в словаре)


def name_a_number(number: int, negative_number=True) -> str:
    '''Возвращает прописью значение числа до 12 разрядов
    
    negative_number=True - добавляет "минус" для отрицательного числа'''

    try:
        _name_digit = { # Определим названия для цифр в разрядах.
        '0': ('ноль', '', '', ''), # Пустые значения для нулей внутри числа
        '1': ('одинадцать ', 'один ', 'десять ', 'сто '),
        '2': ('двенадцать ', 'два ', 'двадцать ', 'двести '),
        '3': ('тринадцать ', 'три ', 'тридцать ', 'триста '),
        '4': ('четырнадцать ', 'четыре ', 'сорок ', 'четыреста '),
        '5': ('пятнадцать ', 'пять ', 'пятьдесят ', 'пятьсот '),
        '6': ('шестнадцать ', 'шесть ', 'шестьдесят ', 'шестьсот '),
        '7': ('семнадцать ', 'семь ', 'семьдесят ', 'семьсот '),
        '8': ('восемнадцать ', 'восемь ', 'восемьдесят ', 'восемьсот '),
        '9': ('девятнадцать ', 'девять ', 'девяносто ', 'девятьсот '),
            }

        _additional_name = { # Дополнительные "имена" для разрядов (троек)
        1: ('', '', ''), # Нужно для первых трех разрядов (для вывода по №)
        2: ('тысяч', 'тысяча', 'тысячи'),
        3: ('миллионов', 'миллион', 'миллиона'),
        4: ('миллиардов', 'миллиард', 'миллиарда'),
        # 5: ('Aрдов', 'Ард', 'Арда') # Проверка на расширяемость (длины числа)
        } # Если известны названия для следующих элементов - можно добавить сюда

        _number_of_digits = len(_additional_name) * 3 # Макс.длина числа (указать в описании)

        #currency_name = { # Можно добавить приписку для валюты
        # _big : ('рублей', 'рубль', 'рубля'),
        # _small : ('копеек', 'копейка', 'копейки')}
        # Но лучше это в другую ф-ю определить.
        

        # Составим ф-ю для названия 3 разрядов.
        def _321_name(_depth_3: str) -> str:
            '''Называет число до 3 разрядов'''

            # Т.к. надо всего 3 элемента описать, то проще перечислением поштучно.
            _text3 = _name_digit.get(_depth_3[-3])[3] # Сотни
            if _depth_3[-2] == '1' and _depth_3[-1] != '0': # от 11 до 19
                _text2 = _name_digit.get(_depth_3[-1])[0]
                _text1 = ''
            else:    
                _text2 = _name_digit.get(_depth_3[-2])[2] # Десятки
                _text1 = _name_digit.get(_depth_3[-1])[1] # Единицы
            return _text3 + _text2 + _text1

        
        if negative_number == True and number < 0: # Проверка на отрицательное число
            _minus = 'минус ' # добавляем "минус" перед названием
        else: 
            _minus = '' # Можно заменить на "плюс" (при необходимости)

        if number == 0: 
            number_name = 'ноль' # Для входящего нуля - выдать НОЛЬ
        else:

            _str_num = str(abs(number)) # Преобразуем в строку для возможности обработки.
            
            if len(_str_num) > _number_of_digits: # Проверка на макс. рязрядность
                number_name = 'Слишком большое число' # Почти исключение
            else: 

                # Определим кол-во троек (и добавим нули в начало)
                _count_3 = len(_str_num) // 3 # Кол-во полных троек
                _count_03 = len(_str_num) % 3 # цифр в неполной тройке
                    
                if _count_03 != 0: # Если не кратно полным тройкам
                    _count_3 += 1 # Увеличим кол-во троек до следующего значения
                    while _count_03 <= 2: # Добавим нулей в начало до кратности 3
                        _str_num = '0' + _str_num
                        _count_03 += 1

                # print('!', _str_num, _count_3) #!проверка: число с нулями в начале и кол-во троек

                # Разобъем число по полным тройкам
                _threes = [] # Для списка из строки по тройкам
                i = 0 # Для вырезки по три
                while _count_3 > 0:
                    _threes.append(_str_num[i: i+3])
                    i += 3
                    _count_3 -= 1

                # print('!', _threes) #!Проверочный вывод списка по тройкам!

                # Назовем все тройки по-порядку
                _size_L = len(_threes) # Количество троек для цикла
                _names_ = [] # Список для составления названия
                _ind = _size_L - 2 # Индекс для замены слов для Тысяч 

                while _size_L > 0: # Проходим по каждой тройке
                    _names_.append(_321_name(_threes[-_size_L])) # Получаем имя тройки

                    if _size_L == 2: # Заменим для тысяч (1 и 2)
                        _text = _names_[_ind]
                        _text = _text.replace('два ', 'две ')
                        _text = _text.replace('один ', 'одна ')
                        _names_[_ind] = _text

                    # Найдем индекс для выбора дополнительного имени
                    j = int(_threes[-_size_L][-1]) # Получаем последнее число каждой тройки
                    if int(_threes[-_size_L][-2]) == 1 or j > 4: j = 0 # Проверка на 11-19 и пр.
                    elif 1 < j <= 4: j = 2 # Для 2-4 в конце (иначе = 1)

                    # Добавим в список дополнительное имя (для разрядов)
                    if _threes[-_size_L] == '000': # Проверяем на наличие цифр в тройке
                        _names_.append('') # Не добавляем "имена", если нет значений
                    else:
                        _names_.append(_additional_name.get(_size_L)[j])

                    _ind += 1 # Честно: определил способ методом научного тыка :)
                    _size_L -= 1

                # Получаем полное название, удаляем двойные пробелы внутри и пробел в конце
                number_name = _minus + ' '.join(_names_).replace('  ', ' ').strip(' ')

        return number_name
    
    except: print('Error: invalid argument for the function')
    


# Определенно, эту запись можно оптимизировать (буду рад обратной связи с подсказками)
# Но в целом, она - работает, и расширяема на новые длины. 
# А главное - гораздо полезнее и интереснее (сложнее) в использовании и разработке.


# Проверка Решения 2.  

n = -518_391_472_601   # Зададим любое подходящее число 

print(name_a_number(n, 0))  # Получим результат (минус - отключен, можно изменить)

# Конец проверки. Конец Решения 2.


print('\n') # Пустая строка для разделения вывода в консоли
